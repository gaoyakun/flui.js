// Generated by dts-bundle v0.7.3

declare module 'flui' {
    export * from 'flui/types';
    export * from 'flui/font';
    export * from 'flui/renderer';
    export * from 'flui/atlas_manager';
    export * from 'flui/glyph_manager';
    export * from 'flui/layout';
    export * from 'flui/style';
    export * from 'flui/texture_atlas';
    export * from 'flui/primitive';
    export * from 'flui/image_manager';
    export * from 'flui/events';
    export * from 'flui/gui';
    export * from 'flui/nodelist';
    export * from 'flui/node';
    export * from 'flui/element';
    export * from 'flui/selector';
    export * from 'flui/style_element';
    export * from 'flui/flow_element';
    export * from 'flui/dummy_element';
    export * from 'flui/document';
    export * from 'flui/components/text';
    export * from 'flui/components/button';
    export * from 'flui/components/input';
    export * from 'flui/components/select';
    export * from 'flui/components/slider';
    export * from 'flui/components/scrollbar';
    export * from 'flui/hittest_visitor';
}

declare module 'flui/types' {
    export interface Vec2 {
        x: number;
        y: number;
    }
    export interface Vec3 extends Vec2 {
        z: number;
    }
    export interface Vec4 extends Vec3 {
        w: number;
    }
    export type EventHandler = (evt: Event) => void;
    export interface EventHandlerObject {
        handleEvent: EventHandler;
    }
    export type EventListener = EventHandler | EventHandlerObject;
    export class Event {
        constructor(type: string, initOptions?: {
            bubbles?: boolean;
            cancelable?: boolean;
        });
        get type(): string;
        get bubbles(): boolean;
        get cancelable(): boolean;
        get cancelBubble(): boolean;
        get cancelImmediate(): boolean;
        set cancelBubble(val: boolean);
        get defaultPrevented(): boolean;
        get target(): unknown;
        get currentTarget(): unknown;
        get timestamp(): number;
        preventDefault(): void;
        stopPropagation(): void;
        stopImmediatePropagation(): void;
    }
    export interface EventTarget {
        addEventListener(type: string, callback: EventListener): void;
        removeEventListener(type: string, callback: EventListener): void;
        dispatchEvent(evt: Event): boolean;
    }
    export function eventtarget(): (ctor: any) => void;
    export interface Texture {
    }
}

declare module 'flui/font' {
    export class FontCanvas {
        static get canvas(): HTMLCanvasElement;
        static get context(): CanvasRenderingContext2D;
        static get font(): Font;
        static set font(font: Font);
    }
    export class Font {
        constructor(name: string);
        get fontName(): string;
        set fontName(name: string);
        get size(): number;
        get family(): string;
        get top(): number;
        get bottom(): number;
        get maxHeight(): number;
        equalTo(other: Font): boolean;
    }
}

declare module 'flui/renderer' {
    import { Vec4 } from 'flui/';
    export interface Renderer {
        getCanvas(): HTMLCanvasElement;
        getDrawingBufferWidth(): number;
        getDrawingBufferHeight(): number;
        createTexture(width: number, height: number, color: Vec4, linear: boolean): unknown;
        updateTextureWithImage(texture: unknown, bitmap: ImageData, x: number, y: number): void;
        updateTextureWithCanvas(texture: unknown, ctx: CanvasRenderingContext2D, cvsOffsetX: number, cvsOffsetY: number, w: number, h: number, x: number, y: number): void;
        getTextureWidth(texture: unknown): number;
        getTextureHeight(texture: unknown): number;
        disposeTexture(texture: unknown): void;
        setCursorStyle(style: string): void;
        getCursorStyle(): string;
        drawQuads(data: Float32Array, texture: unknown): void;
        beginRender(): void;
        endRender(): void;
    }
    export class CanvasRenderer implements Renderer {
        constructor(cvs: HTMLCanvasElement | CanvasRenderingContext2D);
        getCanvas(): HTMLCanvasElement;
        getContext(): CanvasRenderingContext2D;
        getDrawingBufferWidth(): number;
        getDrawingBufferHeight(): number;
        createTexture(width: number, height: number, color: Vec4, linear: boolean): unknown;
        updateTextureWithImage(texture: unknown, bitmap: ImageData, x: number, y: number): void;
        updateTextureWithCanvas(texture: unknown, ctx: CanvasRenderingContext2D, cvsOffsetX: number, cvsOffsetY: number, w: number, h: number, x: number, y: number): void;
        getTextureWidth(texture: unknown): number;
        getTextureHeight(texture: unknown): number;
        disposeTexture(texture: unknown): void;
        setCursorStyle(style: string): void;
        getCursorStyle(): string;
        drawQuads(data: Float32Array, texture: unknown): void;
        beginRender(): void;
        endRender(): void;
    }
}

declare module 'flui/atlas_manager' {
    import { Texture } from 'flui/types';
    import { Renderer } from 'flui/renderer';
    export interface IAtlasInfo {
        atlasIndex: number;
        width: number;
        height: number;
        uMin: number;
        vMin: number;
        uMax: number;
        vMax: number;
    }
    export class AtlasManager<U extends AtlasManager<any> = AtlasManager<any>> {
        constructor(renderer: Renderer, cacheWidth?: number, cacheHeight?: number, cachePadding?: number, linearSpace?: boolean);
        getAtlasTexture(index: number): Texture;
        getAtlasInfo(key: string): IAtlasInfo;
        dispose(): void;
        pushCanvas(key: string, ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number): IAtlasInfo;
        pushBitmap(key: string, bitmap: ImageData): IAtlasInfo;
    }
}

declare module 'flui/glyph_manager' {
    import { Renderer, Texture, Font, AtlasManager } from 'flui/';
    export interface IGlyphInfo {
        atlasIndex: number;
        width: number;
        height: number;
        uMin: number;
        vMin: number;
        uMax: number;
        vMax: number;
    }
    export class GlyphManager extends AtlasManager<GlyphManager> {
        constructor(renderer: Renderer, cacheWidth?: number, cacheHeight?: number, cachePadding?: number);
        getGlyphTexture(index: number): Texture;
        getGlyphInfo(char: string, font: Font): IGlyphInfo;
        measureStringWidth(str: string, charMargin: number, font: Font): number;
        clipStringToWidth(str: string, width: number, charMargin: number, start: number, font: Font): number;
    }
}

declare module 'flui/layout' {
    export interface UIRect {
        x: number;
        y: number;
        width: number;
        height: number;
    }
}

declare module 'flui/style' {
    import { Vec4 } from 'flui/types';
    export class ElementStyle {
        static get defaultBackgroundColor(): Vec4;
        static get defaultBorderColor(): Vec4;
        static get defaultFontColor(): Vec4;
        get display(): string;
        set display(val: string);
        get position(): string;
        set position(val: string);
        get overflow(): string;
        set overflow(val: string);
        get overflowX(): string;
        set overflowX(val: string);
        get overflowY(): string;
        set overflowY(val: string);
        get left(): string | number;
        set left(val: string | number);
        get top(): string | number;
        set top(val: string | number);
        get right(): string | number;
        set right(val: string | number);
        get bottom(): string | number;
        set bottom(val: string | number);
        get width(): string | number;
        set width(val: string | number);
        get minWidth(): string | number;
        set minWidth(val: string | number);
        get maxWidth(): string | number;
        set maxWidth(val: string | number);
        get height(): string | number;
        set height(val: string | number);
        get minHeight(): string | number;
        set minHeight(val: string | number);
        get maxHeight(): string | number;
        set maxHeight(val: string | number);
        get flexDirection(): string;
        set flexDirection(val: string);
        get flexWrap(): string;
        set flexWrap(val: string);
        get flexFlow(): string | number;
        set flexFlow(val: string | number);
        get alignItems(): string;
        set alignItems(val: string);
        get alignContent(): string;
        set alignContent(val: string);
        get alignSelf(): string;
        set alignSelf(val: string);
        get justifyContent(): string;
        set justifyContent(val: string);
        get flexGrow(): string | number;
        set flexGrow(val: string | number);
        get flexShrink(): string | number;
        set flexShrink(val: string | number);
        get flexBasis(): string | number;
        set flexBasis(val: string | number);
        get flex(): string | number;
        set flex(val: string | number);
        get borderColor(): string | number;
        set borderColor(val: string | number);
        get borderLeftColor(): string | number;
        set borderLeftColor(val: string | number);
        get borderTopColor(): string | number;
        set borderTopColor(val: string | number);
        get borderRightColor(): string | number;
        set borderRightColor(val: string | number);
        get borderBottomColor(): string | number;
        set borderBottomColor(val: string | number);
        get borderWidth(): string | number;
        set borderWidth(val: string | number);
        get borderLeftWidth(): string | number;
        set borderLeftWidth(val: string | number);
        get borderTopWidth(): string | number;
        set borderTopWidth(val: string | number);
        get borderRightWidth(): string | number;
        set borderRightWidth(val: string | number);
        get borderBottomWidth(): string | number;
        set borderBottomWidth(val: string | number);
        get margin(): string | number;
        set margin(val: string | number);
        get marginLeft(): string | number;
        set marginLeft(val: string | number);
        get marginTop(): string | number;
        set marginTop(val: string | number);
        get marginRight(): string | number;
        set marginRight(val: string | number);
        get marginBottom(): string | number;
        set marginBottom(val: string | number);
        get padding(): string | number;
        set padding(val: string | number);
        get paddingLeft(): string | number;
        set paddingLeft(val: string | number);
        get paddingTop(): string | number;
        set paddingTop(val: string | number);
        get paddingRight(): string | number;
        set paddingRight(val: string | number);
        get paddingBottom(): string | number;
        set paddingBottom(val: string | number);
        get zIndex(): string | number;
        set zIndex(val: string | number);
        get cursor(): string;
        set cursor(val: string);
        get backgroundColor(): string;
        set backgroundColor(val: string);
        get backgroundImage(): string;
        set backgroundImage(val: string);
        get font(): string;
        set font(val: string);
        get fontSize(): string;
        set fontSize(val: string);
        get fontFamily(): string;
        set fontFamily(val: string);
        get color(): string;
        set color(val: string);
        unescapeCSSString(s: string): string;
    }
}

declare module 'flui/texture_atlas' {
    import { Vec2, Texture } from 'flui/';
    export class TextureAtlas {
        constructor(texture?: Texture, uvMin?: Vec2, uvMax?: Vec2, topLeftPatch9?: Vec2, bottomRightPatch9?: Vec2);
        get texture(): Texture;
        set texture(tex: Texture);
        get uvMin(): Vec2;
        set uvMin(v: Vec2);
        get uvMax(): Vec2;
        set uvMax(v: Vec2);
        get topLeftPatch9(): Vec2;
        set topLeftPatch9(v: Vec2);
        get bottomRightPatch9(): Vec2;
        set bottomRightPatch9(v: Vec2);
    }
}

declare module 'flui/primitive' {
    import { UIRect, Vec4, Texture } from 'flui/';
    export abstract class RMLPrimitive {
        abstract forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: any): any;
        abstract clipToRect(x: number, y: number, w: number, h: number): RMLPrimitive;
    }
    type Vertex = {
        x: number;
        y: number;
        u?: number;
        v?: number;
    };
    export class RMLPolygonPrimitive extends RMLPrimitive {
        constructor(vertices?: Vertex[]);
        get vertices(): Vertex[];
        set vertices(v: Vertex[]);
        forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: any): void;
        clipToRect(x: number, y: number, w: number, h: number): RMLPrimitive;
    }
    export class RMLRectPrimitive extends RMLPrimitive {
        constructor(x: number, y: number, w: number, h: number, uMin: number, vMin: number, uMax: number, vMax: number);
        forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: any): void;
        clipToRect(x: number, y: number, w: number, h: number): RMLPrimitive;
    }
    export class RMLPrimitiveBatchList {
        constructor(x: number, y: number);
        get length(): number;
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);
        clear(): void;
        getBatch(index: number): RMLPrimitiveBatch;
        getVertices(index: number): Float32Array;
        addBatch(batch: RMLPrimitiveBatch): void;
        addPrimitive(prim: RMLPrimitive, clipper: UIRect, tex?: Texture, color?: Vec4): void;
    }
    export class RMLPrimitiveBatch {
        constructor(clipper: UIRect);
        get texture(): Texture;
        set texture(tex: Texture);
        get color(): Vec4;
        set color(clr: Vec4);
        get length(): number;
        getPrimitive(index: number): RMLPrimitive;
        addPrimitive(prim: RMLPrimitive): void;
        setClipper(rect: UIRect): void;
        isSameClipper(rc: UIRect): boolean;
        clear(): void;
    }
    export {};
}

declare module 'flui/image_manager' {
    import { TextureAtlas, Renderer } from 'flui/';
    export class ImageManager {
        constructor(renderer: Renderer);
        get renderer(): Renderer;
        getImage(name: string): TextureAtlas;
        dispose(): void;
    }
}

declare module 'flui/events' {
    import { RMLNode, RMLPrimitiveBatchList, Event } from 'flui/';
    export class GUIMouseEvent extends Event {
        static readonly NAME_MOUSEDOWN = "mousedown";
        static readonly NAME_MOUSEUP = "mouseup";
        static readonly NAME_MOUSEMOVE = "mousemove";
        static readonly NAME_MOUSECLICK = "click";
        static readonly NAME_MOUSEDBLCLICK = "dblclick";
        static readonly NAME_MOUSEENTER = "mouseenter";
        static readonly NAME_MOUSELEAVE = "mouseleave";
        static readonly NAME_MOUSEIN = "mousein";
        static readonly NAME_MOUSEOUT = "mouseout";
        x: number;
        y: number;
        button: number;
        keymod: number;
        constructor(type: string, x: number, y: number, button: number, keymod: number);
    }
    export class GUIKeyEvent extends Event {
        static readonly NAME_KEYDOWN = "keydown";
        static readonly NAME_KEYUP = "keyup";
        static readonly NAME_KEYPRESS = "keypress";
        key: number;
        name: string;
        charCode: number;
        repeat: boolean;
        keymod: number;
        constructor(type: string, key: number, name: string, charcode: number, repeat: boolean, keymod: number);
    }
    export class GUIFocusEvent extends Event {
        static readonly NAME_FOCUS = "focus";
        static readonly NAME_BLUR = "blur";
        constructor(type: string);
    }
    export class ElementLayoutEvent extends Event {
        static readonly NAME = "layout";
        constructor();
    }
    export class ElementBuildContentEvent extends Event {
        static readonly NAME_PREBUILD = "prebuildcontent";
        static readonly NAME_POSTBUILD = "postbuildcontent";
        batchList: RMLPrimitiveBatchList;
        constructor(type: string, batchList: RMLPrimitiveBatchList);
    }
    export class ElementHittestEvent extends Event {
        static readonly NAME = "hittest";
        x: number;
        y: number;
        allow: boolean;
        constructor(x: number, y: number);
    }
    export class TextEvent extends Event {
        static readonly NAME_CONTENT_CHANGE = "textcontentchange";
        static readonly NAME_FONT_CHANGE = "textfontchange";
        constructor(type: string);
    }
    export class ValueChangeEvent extends Event {
        static readonly NAME = "valuechange";
        value: number;
        constructor(value: number);
    }
    export class AttributeChangeEvent extends Event {
        static readonly NAME = "attributechange";
        name: string;
        removed: boolean;
        constructor(name: string, removed: boolean);
    }
    export class TextContentChangeEvent extends Event {
        static readonly NAME = "elementtextcontentchange";
        constructor();
    }
    export class DOMTreeEvent extends Event {
        static readonly NAME_INSERTED = "elementinserted";
        static readonly NAME_REMOVED = "elementremoved";
        static readonly NAME_FOCUSED = "elementfocused";
        parent: RMLNode;
        constructor(type: string, parent: RMLNode);
    }
}

declare module 'flui/gui' {
    import { Renderer, ImageManager, UIRect, RMLNode, RMLElement, RMLDocument, EventTarget } from 'flui/';
    interface IElementConstructor {
        new (gui: GUI, ...args: any[]): any;
    }
    interface ITagNameGetter {
        (element: RMLElement): string;
    }
    export class ElementRegistry {
        constructor();
        register(ctor: IElementConstructor, tagname: string | ITagNameGetter): void;
        createElement(gui: GUI, tagname: string): RMLElement;
    }
    export function tagname(name: string): (ctor: IElementConstructor) => void;
    export interface GUI extends EventTarget {
    }
    export class GUI {
        constructor(renderer: Renderer, bounds?: UIRect);
        get renderer(): Renderer;
        get bounds(): UIRect;
        set bounds(rect: UIRect);
        get baseURI(): string;
        set baseURI(val: string);
        get document(): RMLDocument;
        get imageManager(): ImageManager;
        getFocus(): RMLNode<RMLNode<any>>;
        setFocus(node: RMLNode): void;
        getCapture(): RMLNode<RMLNode<any>>;
        setCapture(node: RMLNode): void;
        dispose(): void;
        invalidateLayout(): void;
        requireFullStyleRefresh(): void;
        checkAndRefreshStyle(): void;
        updateLayout(): void;
        hitTest(x: number, y: number): {
            element: RMLNode;
            x: number;
            y: number;
        }[];
        render(): void;
        serializeToXML(): string;
        deserializeFromXML(xml: string): Promise<any>;
        deserializeFromURL(url: string): Promise<void>;
        createElement<T extends RMLElement = RMLElement>(tagname: string): T;
    }
    export {};
}

declare module 'flui/nodelist' {
    import { RMLNode } from 'flui/';
    export interface RMLNodeList {
        length: number;
        item(index: number): RMLNode;
        entries(): Iterable<[number, RMLNode]>;
        keys(): Iterable<number>;
        values(): Iterable<RMLNode>;
        indexOf(node: RMLNode): number;
        forEach(callback: (currentValue: RMLNode, currentIndex?: number, listObj?: RMLNodeList) => void, thisArg?: any): void;
        [index: number]: RMLNode;
    }
}

declare module 'flui/node' {
    import { Vec2, EventTarget, RMLElement, RMLDocument, RMLNodeList, Renderer, GUI, UIRect, ElementStyle } from 'flui/';
    export interface RMLNode<U = RMLNode<any>> extends EventTarget {
    }
    export interface INodeVisitor {
        visitNode(w: RMLNode): void;
    }
    export class RMLNode<U extends RMLNode<any> = RMLNode<any>> {
        static readonly UNKNOWN_NODE = 0;
        static readonly ELEMENT_NODE = 1;
        static readonly TEXT_NODE = 3;
        static readonly DOCUMENT_NODE = 9;
        get gui(): GUI;
        get nodeType(): number;
        get nodeName(): string;
        get nodeValue(): string;
        get ownerDocument(): RMLDocument;
        get isConnected(): boolean;
        get parentNode(): RMLNode;
        get parentElement(): RMLElement;
        get childNodes(): RMLNodeList;
        get style(): ElementStyle;
        get textContent(): string;
        set textContent(text: string);
        normalize(): void;
        get scrollX(): number;
        set scrollX(val: number);
        setScrollX(val: number): void;
        get scrollY(): number;
        set scrollY(val: number);
        setScrollY(val: number): void;
        setScroll(x: number, y: number): void;
        getRect(): UIRect;
        getClippedRect(): UIRect;
        getClientRect(): UIRect;
        getBorderRect(): UIRect;
        enable(): void;
        disable(): void;
        get enabled(): boolean;
        set enabled(enable: boolean);
        get nextSibling(): RMLNode;
        get previousSibling(): RMLNode;
        cloneNode(deep: boolean): RMLNode;
        getRootNode(): RMLNode;
        appendChild(child: RMLNode): RMLNode;
        insertBefore(newElement: RMLNode, referenceElement: RMLNode): RMLNode<RMLNode<any>>;
        removeChild(child: RMLNode): RMLNode<RMLNode<any>>;
        replaceChild(newChild: RMLNode, oldChild: RMLNode): RMLNode<RMLNode<any>>;
        get firstChild(): RMLNode;
        get lastChild(): RMLNode;
        contains(child: RMLNode): boolean;
        hasChildNodes(): boolean;
        setCapture(): void;
        releaseCapture(): void;
        traverse(v: INodeVisitor, inverse?: boolean, render?: boolean): void;
        draw(renderer: Renderer): void;
        toAbsolute(v: Vec2): Vec2;
        protected _updateScrollState(): void;
    }
}

declare module 'flui/element' {
    import { RMLNode, GUI, RMLNodeList } from 'flui/';
    export interface RMLClassList {
        [n: number]: string;
    }
    export class RMLClassList {
        constructor(el: RMLElement);
        get value(): string;
        set value(val: string);
        get length(): number;
        add(...args: string[]): void;
        remove(...args: string[]): void;
        toggle(className: string): boolean;
        contains(className: string): boolean;
        replace(oldClassName: string, newClassName: string): void;
    }
    export interface RMLAttr {
        name: string;
        value: string;
    }
    export class RMLElement<U extends RMLElement<any> = RMLElement<any>> extends RMLNode<U> {
        constructor(uiscene: GUI);
        get children(): RMLNodeList;
        get childElementCount(): number;
        get nodeType(): number;
        get localName(): string;
        get tagName(): string;
        get id(): string;
        set id(id: string);
        get classList(): RMLClassList;
        get className(): string;
        get attributes(): RMLAttr[];
        get firstElementChild(): RMLElement;
        get lastElementChild(): RMLElement;
        get nextElementSibling(): RMLElement;
        get previousElementSibling(): RMLElement;
        getAttribute(k: string): string;
        setAttribute(k: string, v?: string): void;
        removeAttribute(k: string): void;
        hasAttribute(k: string): boolean;
        hasAttributes(): boolean;
        insertAdjacentElement(position: string, element: RMLElement): RMLElement<RMLElement<any>>;
        insertAdjacentText(position: string, text: string): string;
        matches(selectorString: string): boolean;
        cloneNode(deep: boolean): RMLNode;
        replaceWith(...nodes: (RMLNode | string)[]): void;
        remove(): RMLNode;
        before(...nodes: (RMLNode | string)[]): void;
        after(...nodes: (RMLNode | string)[]): void;
        append(...nodes: (RMLNode | string)[]): void;
        prepend(...nodes: (RMLNode | string)[]): void;
        querySelectorAll(selectors: string): RMLNodeList;
        querySelector(selectors: string): RMLElement;
        getElementById(id: string): RMLElement;
        getElementsByTagName(tagname: string): RMLNodeList;
        getElementsByClassName(classnames: string): RMLNodeList;
    }
}

declare module 'flui/selector' {
    import { RMLNode } from 'flui/';
    import { List } from 'flui/misc';
    enum Combine {
        NONE = 0,
        DESCEND = 1,
        CHILD = 2,
        SIBLING = 3,
        ADJACENT = 4
    }
    enum Op {
        ANY = 0,
        EQUAL = 1,
        CONTAINS = 2,
        START = 3,
        END = 4
    }
    enum Filter {
        NONE = 0,
        TAGNAME = 1,
        CLASS = 2,
        ID = 3,
        COMBINE = 4,
        ATTRIBUTE = 5,
        PSEUDO_CLASS = 6,
        PSEUDO_ELEMENT = 7
    }
    interface FilterInfo {
        type: Filter;
        name?: string;
        combineType?: Combine;
        attribOp?: Op;
        attribKey?: string;
        attribValue?: string;
        numIds?: number;
        numClasses?: number;
        numTypes?: number;
    }
    interface IPseudoElementCallback {
        (node: RMLNode, pseudoType: string): void;
    }
    export class Rule {
        filters: List<FilterInfo>;
        targets: Set<RMLNode>;
        specificity: number;
        constructor();
        resolve(roots: RMLNode[], up: boolean, allowInternal: boolean, pseudoElementCallback?: IPseudoElementCallback): void;
    }
    export class RMLSelector {
        protected _rules: Rule[];
        constructor(s: string);
        resolve(root: RMLNode, excludeRoot: boolean, allowInternal: any): RMLNode[];
        multiResolve(roots: RMLNode[], allowInternal: any): RMLNode[];
        rules(): Rule[];
    }
    export {};
}

declare module 'flui/style_element' {
    import { RMLElement, GUI } from 'flui/';
    export class StyleElement extends RMLElement<StyleElement> {
        constructor(uiscene: GUI);
    }
}

declare module 'flui/flow_element' {
    import { RMLElement, GUI } from 'flui/';
    export class FlowElement extends RMLElement<FlowElement> {
        constructor(uiscene: GUI);
    }
}

declare module 'flui/dummy_element' {
    import { RMLElement, GUI } from 'flui/';
    export class DummyElement extends RMLElement<DummyElement> {
        constructor(uiscene: GUI);
    }
}

declare module 'flui/document' {
    import { RMLNode, RMLElement, GUI, RMLNodeList } from 'flui/';
    export class RMLDocument extends RMLNode<RMLDocument> {
        constructor(uiscene: GUI);
        get nodeType(): number;
        get nodeName(): string;
        get head(): RMLElement;
        get body(): RMLElement;
        get baseURI(): string;
        set baseURI(val: string);
        get textContent(): string;
        set textContent(val: string);
        get documentElement(): RMLElement;
        get children(): RMLNodeList;
        get childElementCount(): number;
        get firstElementChild(): RMLElement;
        get lastElementChild(): RMLElement;
        appendChild(child: RMLNode): RMLNode;
        insertBefore(newElement: RMLNode, referenceElement: RMLNode): RMLNode<RMLNode<any>>;
        append(...nodes: (RMLNode | string)[]): void;
        prepend(...nodes: (RMLNode | string)[]): void;
        querySelectorAll(selectors: string): RMLNodeList;
        querySelector(selectors: string): RMLElement;
        getElementsByTagName(tagname: string): RMLNodeList;
        getElementsByClassName(classnames: string): RMLNodeList;
        getElementById(id: string): RMLElement;
        createElement<T extends RMLElement = RMLElement>(tagname: string): T;
    }
}

declare module 'flui/components/text' {
    import { RMLNode, GUI } from 'flui/';
    export class Text<U extends Text<any> = Text<any>> extends RMLNode<U> {
        constructor(uiscene: GUI);
        get nodeType(): number;
        cloneNode(deep: boolean): RMLNode;
        get textContent(): string;
        set textContent(text: string);
        get autoWrap(): boolean;
        set autoWrap(val: boolean);
        get charMargin(): number;
        set charMargin(val: number);
        get lineHeight(): number;
        set lineHeight(val: number);
    }
}

declare module 'flui/components/button' {
    import { RMLElement, GUI } from 'flui/';
    export class Button extends RMLElement<Button> {
        constructor(uiscene: GUI);
    }
}

declare module 'flui/components/input' {
    import { GUI, RMLElement, Renderer } from 'flui/';
    export class Input extends RMLElement<Input> {
        constructor(uiscene: GUI);
        protected _draw(renderer: Renderer): void;
        get type(): string;
        set type(val: string);
        protected _buildVertexData(): void;
    }
}

declare module 'flui/components/select' {
    import { GUI, RMLElement } from 'flui/';
    export class Option extends RMLElement<Option> {
        constructor(uiscene: GUI);
        setAttribute(k: string, v?: string): void;
    }
    export class Select extends RMLElement<Select> {
        constructor(uiscene: GUI);
    }
}

declare module 'flui/components/slider' {
    import { RMLElement, GUI } from 'flui/';
    export class Slider extends RMLElement<Slider> {
        constructor(uiscene: GUI);
        get value(): number;
        set value(val: number);
        get rangeStart(): number;
        set rangeStart(val: number);
        get rangeEnd(): number;
        set rangeEnd(val: number);
        get blockSize(): number;
        set blockSize(val: number);
        get stepValue(): number;
        set stepValue(val: number);
        get pageValue(): number;
        set pageValue(val: number);
        get orientation(): string;
        set orientation(val: string);
        get blockColor(): string;
        set blockColor(val: string);
        get blockImage(): string;
        set blockImage(val: string);
    }
}

declare module 'flui/components/scrollbar' {
    import { GUI, Slider } from 'flui/';
    export class ScrollBar extends Slider {
        constructor(uiscene: GUI);
        get buttonSize(): number;
        set buttonSize(val: number);
        protected _onAttributeChange(name: string): void;
        protected _updateScrollState(): void;
    }
}

declare module 'flui/hittest_visitor' {
    import { RMLNode } from 'flui/';
    export class GUIHitTestVisitor {
        constructor(x: number, y: number);
        getHits(): {
            element: RMLNode;
            x: number;
            y: number;
        }[];
        visitNode(w: RMLNode): void;
    }
}

declare module 'flui/' {
    export * from 'flui/types';
    export * from 'flui/font';
    export * from 'flui/renderer';
    export * from 'flui/atlas_manager';
    export * from 'flui/glyph_manager';
    export * from 'flui/layout';
    export * from 'flui/style';
    export * from 'flui/texture_atlas';
    export * from 'flui/primitive';
    export * from 'flui/image_manager';
    export * from 'flui/events';
    export * from 'flui/gui';
    export * from 'flui/nodelist';
    export * from 'flui/node';
    export * from 'flui/element';
    export * from 'flui/selector';
    export * from 'flui/style_element';
    export * from 'flui/flow_element';
    export * from 'flui/dummy_element';
    export * from 'flui/document';
    export * from 'flui/components/text';
    export * from 'flui/components/button';
    export * from 'flui/components/input';
    export * from 'flui/components/select';
    export * from 'flui/components/slider';
    export * from 'flui/components/scrollbar';
    export * from 'flui/hittest_visitor';
}

declare module 'flui/misc' {
    export * from 'flui/misc/linkedlist';
    export * from 'flui/misc/visitor';
    export * from 'flui/misc/string_utils';
}

declare module 'flui/misc/linkedlist' {
    export class ListIterator<T = any> {
        constructor(dl: List<T>, node: ListNodeImpl, reverse: boolean);
        valid(): boolean;
        next(): ListIterator<T>;
        getNext(): ListIterator<T>;
        prev(): ListIterator<T>;
        getPrev(): ListIterator<T>;
        get node(): ListNodeImpl;
        set node(n: ListNodeImpl);
        get reversed(): boolean;
        get list(): List<T>;
        get data(): T;
        set data(val: T);
    }
    export class List<T = any> {
        constructor();
        get head(): ListNodeImpl;
        get length(): number;
        clear(): void;
        append(data: T): ListIterator<T>;
        prepend(data: T): ListIterator<T>;
        remove(it: ListIterator<T>): void;
        insertAt(data: T, at: ListIterator<T>): ListIterator<T>;
        forEach(callback: (data: T) => void): void;
        forEachReverse(callback: (data: T) => void): void;
        front(): T;
        back(): T;
        begin(): ListIterator<T>;
        rbegin(): ListIterator<T>;
    }
    class ListNodeImpl {
        next: ListNodeImpl;
        prev: ListNodeImpl;
        constructor();
    }
    export {};
}

declare module 'flui/misc/visitor' {
    interface Constructor<T = any> {
        new (...args: any[]): T;
    }
    export function visitor(T: Constructor): (target: any, propertyKey: string) => void;
    export class Visitor {
        constructor();
        visit(target: object): any;
        visitWithType(target: object, type: Constructor): any;
        static getVisitFunc<T = Visitor, U = any>(visitorType: Constructor<T>, targetType: Constructor<U>): (this: T, target: U) => any;
        static setVisitFunc<T = Visitor, U = any>(visitorType: Constructor<T>, targetType: Constructor<U>, func: (this: T, target: U) => any): void;
        static removeVisitFunc<T = Visitor, U = any>(visitorType: Constructor<T>, targetType: Constructor<U>): void;
    }
    export {};
}

declare module 'flui/misc/string_utils' {
    export function base64ToU8(input: string): Uint8Array;
    export function stringToU8(s: string): Uint8Array;
    export function u8ToString(ua: Uint8Array): string;
}

